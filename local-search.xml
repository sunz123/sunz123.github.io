<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo+github pages+jsdelivr+cloudflare+PicGo实现个人博客</title>
    <link href="/2024/11/06/hexo-github-pages-jsdelivr-cloudflare-PicGo%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/11/06/hexo-github-pages-jsdelivr-cloudflare-PicGo%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github pages</tag>
      
      <tag>jsdliver</tag>
      
      <tag>cloudflare</tag>
      
      <tag>PicGo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP智能指针浅探</title>
    <link href="/2024/11/05/CPP%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B5%85%E6%8E%A2/"/>
    <url>/2024/11/05/CPP%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B5%85%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针是c++11引入的新特性，其本质是封装了一个原始c++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。其头文件是<code>#include &lt;memory&gt;</code></p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><ul><li>unique_ptr 不共享它的指针。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 (STL) 算法。<strong>只能移动unique_ptr</strong>。当需要智能指针用于纯 C++ 对象时，可使用 unique_ptr，而当构造 unique_ptr 时，可使用<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/how-to-create-and-use-unique-ptr-instances?view=vs-2019">make_unique</a> 函数。</li><li>std::unique_ptr 实现了<strong>独享所有权</strong>的语义。转移一个 std::unique_ptr 将会把所有权也从源指针转移给目标指针（源指针被置空）。拷贝一个 std::unique_ptr 将不被允许，因为如果你拷贝一个 std::unique_ptr ,那么拷贝结束后，这两个 std::unique_ptr 都会指向相同的资源，它们都认为自己拥有这块资源（所以都会企图释放）。因此 std::unique_ptr 是一个仅能移动（move_only）的类型。</li></ul><h3 id="2、创建unique-ptr"><a href="#2、创建unique-ptr" class="headerlink" title="2、创建unique_ptr"></a>2、创建unique_ptr</h3><div class="note note-info">            <ul><li>unique_ptr 不像 shared_ptr 一样拥有标准库函数 make_shared 来创建一个 shared_ptr 实例。要想创建一个 unique_ptr，我们需要将一个new 操作符返回的指针传递给 unique_ptr 的构造函数。</li><li>std::make_unique是C++14才有的特性。</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>    cout &lt;&lt; *p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、无法进行复制构造和赋值操作"><a href="#3、无法进行复制构造和赋值操作" class="headerlink" title="3、无法进行复制构造和赋值操作"></a>3、无法进行复制构造和赋值操作</h3><div class="note note-info">            <ul><li>unique_ptr没有copy构造函数，不支持拷贝和赋值操作。</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// 报错</span><br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = p; <span class="hljs-comment">// 报错</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、可以进行移动构造和移动赋值操作"><a href="#4、可以进行移动构造和移动赋值操作" class="headerlink" title="4、可以进行移动构造和移动赋值操作"></a>4、可以进行移动构造和移动赋值操作</h3><div class="note note-info">            <ul><li>可以移交所有权，使用std::move()函数。</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p2 = std::<span class="hljs-built_in">move</span>(p); <span class="hljs-comment">// 转移所有权</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; *p &lt;&lt; endl; // 报错，p为空</span><br>    std::cout &lt;&lt; *p2 &lt;&lt; endl;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(std::move(p2))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、可以返回unique-ptr"><a href="#5、可以返回unique-ptr" class="headerlink" title="5、可以返回unique_ptr"></a>5、可以返回unique_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pI</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>    <span class="hljs-keyword">return</span> pI;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">5</span>;<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; ret = <span class="hljs-built_in">clone</span>(p);<br>    cout &lt;&lt; *ret &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、unique-ptr一些使用场景"><a href="#6、unique-ptr一些使用场景" class="headerlink" title="6、unique_ptr一些使用场景"></a>6、unique_ptr一些使用场景</h3><div class="note note-info">            <ul><li>在容器中保存指针</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;unique_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p));<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <ul><li>管理动态数组</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;)</span></span>;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <ul><li>unique_ptr可以不占用对象，即为空。可以通过reset或者赋值nullptr释放管理对象</li><li>标准库早期版本中定了auto_ptr，它具有unique_ptr的部分特征，但不是全部。例如不能在容器中保存auto_ptr，不能从函数中返回auto_ptr等等，这也是unique_ptr主要的使用场景。</li></ul>          </div><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>shared_ptr是存储动态创建对象的指针，其主要功能是管理动态创建对象的销毁，帮助消除内存泄漏和悬空指针的问题。</p><p>其原理是记录对象被引用次数，当引用次数为0时，也就是最后一个指向该对象的共享指针析构的时候，共享指针的析构函数就把指向的内存区域释放掉。</p><div class="note note-info">            <p>共享指针内存：每个shared_ptr对象在内部指向两个内存位置。</p><ul><li>指向对象的指针；</li><li>用于控制引用计数的指针。</li></ul>          </div><h3 id="2、shared-ptr的创建"><a href="#2、shared-ptr的创建" class="headerlink" title="2、shared_ptr的创建"></a>2、shared_ptr的创建</h3><p>构建空的智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1; <span class="hljs-comment">// 不传入任何实参</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;  <span class="hljs-comment">// 传入空指针nullptr</span><br><span class="hljs-comment">// 空的shared_ptr指针，其初始引用计数为0，而不是1。</span><br></code></pre></td></tr></table></figure><p>明确其指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>还可以使用相应的拷贝构造函数和移动构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 调用拷贝构造函数</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p4</span><span class="hljs-params">(p3)</span></span>; <span class="hljs-comment">// 或者std::shared_ptr&lt;int&gt; p4 = p3;</span><br><span class="hljs-comment">// 调用移动构造函数</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(std::move(p4))</span></span>; <span class="hljs-comment">// 或者std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span><br></code></pre></td></tr></table></figure><p>在初始化shared_ptr智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为0时，会优先调用自定义的释放规则。</p><p>对申请的动态数组，释放规则可以用c++11标准中提供的default_delete模板类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 指定default_delete作为释放规则</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], std::default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br><br><span class="hljs-comment">// 自定义释放规则</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteInt</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">delete</span>[] p;<br>&#125;<br><br><span class="hljs-comment">// 初始化智能指针，并自定义释放规则</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], deleteInt)</span></span>;<br><br><span class="hljs-comment">// 实际上借助lambda表达式，我们还可以像如下这样初始化p7，是完全相同的</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span>[] p;&#125;)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3、share-ptr常用函数"><a href="#3、share-ptr常用函数" class="headerlink" title="3、share_ptr常用函数"></a>3、share_ptr常用函数</h3><ul><li>get()函数，返回当前存储的指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>T* p1 = p.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 获得传统c指针</span><br></code></pre></td></tr></table></figure><ul><li>use_count()函数，当前引用计数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>a.<span class="hljs-built_in">use_count</span>(); <span class="hljs-comment">// 获取当前的引用计数</span><br></code></pre></td></tr></table></figure><ul><li>reset()函数，表示重置当前存储的指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T())</span></span>;<br>a.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 此后 a 原先所指的对象会被销毁，并且 a 会变成 NULL</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://zhida.zhihu.com/search?content_id=209832819&content_type=Article&match_order=1&q=operator&zhida_source=entity">operator</a><em>，表示返回对存储指针指向的对象的引用。它相当于：</em> get（）。</li><li>operator-&gt;，表示返回指向存储指针所指向的对象的指针，以便访问其中一个成员。跟<a href="https://zhida.zhihu.com/search?content_id=209832819&content_type=Article&match_order=1&q=get%E5%87%BD%E6%95%B0&zhida_source=entity">get函数</a>一样的效果。</li></ul><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>weak_ptr主要针对shared_ptr的空悬指针和循环引用问题而提出：</p><ul><li><p>空悬指针问题：有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了（尽管把p1置为了NULL），那p2就成了空悬指针。weak_ptr不控制对象的生命期，但是它知道对象是否还活着。如果对象还活着，那么它可以提升为有效的shared_ptr（提升操作通过lock()函数获取所管理对象的强引用指针）；如果对象已经死了，提升会失败，返回一个空的shared_ptr。</p></li><li><p>循环应用问题</p></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <br><br><span class="hljs-keyword">typedef</span> shared_ptr&lt;A&gt; A_ptr;<br><span class="hljs-keyword">typedef</span> shared_ptr&lt;B&gt; B_ptr; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>       ~<span class="hljs-built_in">A</span>() &#123; <br>              cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; <br>       &#125;<br><span class="hljs-keyword">public</span>:<br>       B_ptr b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>       ~<span class="hljs-built_in">B</span>() &#123; <br>              cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; <br>       &#125;<br><span class="hljs-keyword">public</span>:<br>       A_ptr a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">A_ptr <span class="hljs-title">ap</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A)</span></span>;<br>  <span class="hljs-function">B_ptr <span class="hljs-title">bp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B)</span></span>;<br><br>  <span class="hljs-comment">// 父子互相引用</span><br>  ap-&gt;b = bp;<br>  bp-&gt;a = ap;<br><br>  cout &lt;&lt; ap.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 引用计数为2</span><br>  cout &lt;&lt; bp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;     <span class="hljs-comment">// 引用计数为2</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  如上代码，将在程序退出前，ap的引用计数为2，bp的计数也为2，退出时，shared_ptr所作操作就是简单的将计数减1，如果为0则释放，显然，这个情况下，引用计数不为0，于是造成ap和bp所指向的内存得不到释放，导致内存泄露。</p><p>  使用weak_ptr可以打破这样的循环引用。由于弱引用不更改引用计数，类似普通指针，只要把循环引用的一方使用弱引用，即可解除循环引用。以上述代码为例，只要把B类的代码修改为如下即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>       ~<span class="hljs-built_in">B</span>() &#123; <br>              cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; <br>       &#125;<br><span class="hljs-keyword">public</span>:<br>       std::weak_ptr&lt;A&gt; a;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>最后值得一提的是，虽然通过弱引用指针可以有效的解除循环引用，但这种方式必须在能预见会出现循环引用的情况下才能使用，即这个仅仅是一种编译期的解决方案，如果程序在运行过程中出现了循环引用，还是会造成内存泄漏的。因此，不要认为只要使用了智能指针便能杜绝内存泄漏。</p>          </div><h3 id="weak-ptr创建"><a href="#weak-ptr创建" class="headerlink" title="weak_ptr创建"></a>weak_ptr创建</h3><p>创建一个空weak_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp;<br><span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp1</span><span class="hljs-params">(wp)</span></span>; <span class="hljs-comment">// 使用已有weak_ptr创建新的ptr</span><br></code></pre></td></tr></table></figure><p>weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp3</span><span class="hljs-params">(sp)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="weak-ptr模板类提供的成员方法"><a href="#weak-ptr模板类提供的成员方法" class="headerlink" title="weak_ptr模板类提供的成员方法"></a>weak_ptr模板类提供的成员方法</h3><ul><li>operator&#x3D;()：重载 &#x3D; 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。</li><li>swap(x)：其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。</li><li>reset()：将当前 weak_ptr 指针置为空指针。</li><li>use_count()：查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。</li><li>expired()：判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。</li><li>lock()：如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内存管理</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL的使用</title>
    <link href="/2024/11/05/WSL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/11/05/WSL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、WSL的安装"><a href="#一、WSL的安装" class="headerlink" title="一、WSL的安装"></a>一、WSL的安装</h1><h2 id="1、为Windows启用Linux子系统功能"><a href="#1、为Windows启用Linux子系统功能" class="headerlink" title="1、为Windows启用Linux子系统功能"></a>1、为Windows启用Linux子系统功能</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:Microsoft<span class="hljs-literal">-Windows-Subsystem-Linux</span> /all /norestart<br></code></pre></td></tr></table></figure><h2 id="2、启用Windows的虚拟机功能"><a href="#2、启用Windows的虚拟机功能" class="headerlink" title="2、启用Windows的虚拟机功能"></a>2、启用Windows的虚拟机功能</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart<br></code></pre></td></tr></table></figure><h2 id="3、更新Linux内核"><a href="#3、更新Linux内核" class="headerlink" title="3、更新Linux内核"></a>3、更新Linux内核</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi<br></code></pre></td></tr></table></figure><h2 id="4、设置WSL2为默认版本"><a href="#4、设置WSL2为默认版本" class="headerlink" title="4、设置WSL2为默认版本"></a>4、设置WSL2为默认版本</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--set-default-version</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="5、到微软商店下载Linux系统并安装"><a href="#5、到微软商店下载Linux系统并安装" class="headerlink" title="5、到微软商店下载Linux系统并安装"></a>5、到微软商店下载Linux系统并安装</h2><h1 id="二、WSL的基本指令"><a href="#二、WSL的基本指令" class="headerlink" title="二、WSL的基本指令"></a>二、WSL的基本指令</h1><p>以下 WSL 命令以 PowerShell 或 Windows 命令提示符支持的格式列出。 若要通过 Bash&#x2F;Linux 发行版命令行运行这些命令，必须将 <code>wsl</code> 替换为 <code>wsl.exe</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--install</span><br></code></pre></td></tr></table></figure><p>安装 WSL 和 Linux 的 Ubuntu 发行版。 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">了解详细信息</a>。</p><h2 id="安装特定的-Linux-发行版"><a href="#安装特定的-Linux-发行版" class="headerlink" title="安装特定的 Linux 发行版"></a>安装特定的 Linux 发行版</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--install</span> <span class="hljs-literal">--distribution</span> &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><p>通过将 <code>&lt;Distribution Name&gt;</code> 替换为发行版名称，指定除默认发行版 (Ubuntu) 之外的 Linux 发行版进行安装。 此命令也可输入为：<code>wsl -d &lt;Distribution Name&gt;</code>。</p><h2 id="列出可用的-Linux-发行版"><a href="#列出可用的-Linux-发行版" class="headerlink" title="列出可用的 Linux 发行版"></a>列出可用的 Linux 发行版</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--list</span> <span class="hljs-literal">--online</span><br></code></pre></td></tr></table></figure><p>查看可通过在线商店获得的 Linux 发行版列表。 此命令也可输入为：<code>wsl -l -o</code>。</p><h2 id="列出已安装的-Linux-发行版"><a href="#列出已安装的-Linux-发行版" class="headerlink" title="列出已安装的 Linux 发行版"></a>列出已安装的 Linux 发行版</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--list</span> <span class="hljs-literal">--verbose</span><br></code></pre></td></tr></table></figure><p>查看安装在 Windows 计算机上的 Linux 发行版列表，其中包括状态（发行版是正在运行还是已停止）和运行发行版的 WSL 版本（WSL 1 或 WSL 2）。 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions">比较 WSL 1 和 WSL 2</a>。 此命令也可输入为：<code>wsl -l -v</code>。 可与 list 命令一起使用的其他选项包括：<code>--all</code>（列出所有发行版）、<code>--running</code>（仅列出当前正在运行的发行版）或 <code>--quiet</code>（仅显示发行版名称）。</p><h2 id="将-WSL-版本设置为-1-或-2"><a href="#将-WSL-版本设置为-1-或-2" class="headerlink" title="将 WSL 版本设置为 1 或 2"></a>将 WSL 版本设置为 1 或 2</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--set-version</span> &lt;distribution name&gt; &lt;versionNumber&gt;<br></code></pre></td></tr></table></figure><p>若要指定运行 Linux 发行版的 WSL 版本（1 或 2），请将 <code>&lt;distribution name&gt;</code> 替换为发行版的名称，并将 <code>&lt;versionNumber&gt;</code> 替换为 1 或 2。 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions">比较 WSL 1 和 WSL 2</a>。</p><h2 id="设置默认-WSL-版本"><a href="#设置默认-WSL-版本" class="headerlink" title="设置默认 WSL 版本"></a>设置默认 WSL 版本</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--set-default-version</span> &lt;Version&gt;<br></code></pre></td></tr></table></figure><p>若要将默认版本设置为 WSL 1 或 WSL 2，请将 <code>&lt;Version&gt;</code> 替换为数字 1 或 2，表示对于安装新的 Linux 发行版，你希望默认使用哪个版本的 WSL。 例如，<code>wsl --set-default-version 2</code>。 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/compare-versions">比较 WSL 1 和 WSL 2</a>。</p><h2 id="设置默认-Linux-发行版"><a href="#设置默认-Linux-发行版" class="headerlink" title="设置默认 Linux 发行版"></a>设置默认 Linux 发行版</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--set-default</span> &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><p>若要设置 WSL 命令将用于运行的默认 Linux 发行版，请将 <code>&lt;Distribution Name&gt;</code> 替换为你首选的 Linux 发行版的名称。</p><h2 id="将目录更改为主页"><a href="#将目录更改为主页" class="headerlink" title="将目录更改为主页"></a>将目录更改为主页</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl ~<br></code></pre></td></tr></table></figure><p><code>~</code> 可与 wsl 一起使用，以在用户的主目录中启动。 若要在 WSL 命令提示符中从任何目录跳回到主目录，可使用命令 <code>cd ~</code>。</p><h2 id="通过-PowerShell-或-CMD-运行特定的-Linux-发行版"><a href="#通过-PowerShell-或-CMD-运行特定的-Linux-发行版" class="headerlink" title="通过 PowerShell 或 CMD 运行特定的 Linux 发行版"></a>通过 PowerShell 或 CMD 运行特定的 Linux 发行版</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--distribution</span> &lt;Distribution Name&gt; <span class="hljs-literal">--user</span> &lt;User Name&gt;<br></code></pre></td></tr></table></figure><p>若要通过特定用户运行特定 Linux 发行版，请将 <code>&lt;Distribution Name&gt;</code> 替换为你首选的 Linux 发行版的名称（例如 Debian），将 <code>&lt;User Name&gt;</code> 替换为现有用户的名称（例如 root）。 如果 WSL 发行版中不存在该用户，你将会收到一个错误。 若要输出当前用户名，请使用 <code>whoami</code> 命令。</p><h2 id="更新-WSL"><a href="#更新-WSL" class="headerlink" title="更新 WSL"></a>更新 WSL</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--update</span><br></code></pre></td></tr></table></figure><p>手动更新 WSL Linux 内核的版本。 还可以使用 <code>wsl --update rollback</code> 命令回滚到 WSL Linux 内核的上一版本。</p><h2 id="检查-WSL-状态"><a href="#检查-WSL-状态" class="headerlink" title="检查 WSL 状态"></a>检查 WSL 状态</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--status</span><br></code></pre></td></tr></table></figure><p>查看有关 WSL 配置的常规信息，例如默认发行版类型、默认发行版和内核版本。</p><h2 id="Help-命令"><a href="#Help-命令" class="headerlink" title="Help 命令"></a>Help 命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--help</span><br></code></pre></td></tr></table></figure><p>查看 WSL 中可用的选项和命令列表。</p><h2 id="以特定用户的身份运行"><a href="#以特定用户的身份运行" class="headerlink" title="以特定用户的身份运行"></a>以特定用户的身份运行</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-u</span> &lt;Username&gt;`, `w<span class="hljs-built_in">sl</span> <span class="hljs-literal">--user</span> &lt;Username&gt;<br></code></pre></td></tr></table></figure><p>若要以指定用户身份运行 WSL，请将 <code>&lt;Username&gt;</code> 替换为 WSL 发行版中存在的用户名。</p><h2 id="更改发行版的默认用户"><a href="#更改发行版的默认用户" class="headerlink" title="更改发行版的默认用户"></a>更改发行版的默认用户</h2><p>PowerShell复制</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;DistributionName&gt; config <span class="hljs-literal">--default-user</span> &lt;Username&gt;<br></code></pre></td></tr></table></figure><p>更改用于发行版登录的默认用户。 用户必须已经存在于发行版中才能成为默认用户。</p><p>例如：<code>ubuntu config --default-user johndoe</code> 会将 Ubuntu 发行版的默认用户更改为“johndoe”用户。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure><p>立即终止所有正在运行的发行版和 WSL 2 轻量级实用工具虚拟机。 在需要重启 WSL 2 虚拟机环境的情形下，例如<a href="https://learn.microsoft.com/zh-cn/windows/wsl/vhd-size">更改内存使用限制</a>或更改 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/manage#">.wslconfig 文件</a>，可能必须使用此命令。</p><h2 id="Terminate"><a href="#Terminate" class="headerlink" title="Terminate"></a>Terminate</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--terminate</span> &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><p>若要终止指定的发行版或阻止其运行，请将 <code>&lt;Distribution Name&gt;</code> 替换为目标发行版的名称。</p><h2 id="将发行版导出到-TAR-文件"><a href="#将发行版导出到-TAR-文件" class="headerlink" title="将发行版导出到 TAR 文件"></a>将发行版导出到 TAR 文件</h2><p>PowerShell复制</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--export</span> &lt;Distribution Name&gt; &lt;FileName&gt;<br></code></pre></td></tr></table></figure><p>将分发版导出到 tar 文件。 在标准输出中，文件名可以是 -。</p><h2 id="导入新发行版"><a href="#导入新发行版" class="headerlink" title="导入新发行版"></a>导入新发行版</h2><p>PowerShell复制</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--import</span> &lt;Distribution Name&gt; &lt;InstallLocation&gt; &lt;FileName&gt;<br></code></pre></td></tr></table></figure><p>导入指定的 tar 文件作为新的分发版。 在标准输入中，文件名可以是 -。 <code>--version</code> 选项还可与此命令一起使用，用于指定导入的发行版将在 WSL 1 还是 WSL 2 上运行。</p><h2 id="注销或卸载-Linux-发行版"><a href="#注销或卸载-Linux-发行版" class="headerlink" title="注销或卸载 Linux 发行版"></a>注销或卸载 Linux 发行版</h2><p>尽管可以通过 Microsoft Store 安装 Linux 发行版，但无法通过 Store 将其卸载。</p><p>注销并卸载 WSL 发行版：</p><p>PowerShell复制</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--unregister</span> &lt;DistributionName&gt;<br></code></pre></td></tr></table></figure><p>如果将 <code>&lt;DistributionName&gt;</code> 替换为目标 Linux 发行版的名称，则将从 WSL 取消注册该发行版，以便可以重新安装或清理它。 <strong>警告：</strong>取消注册后，与该分发版关联的所有数据、设置和软件将永久丢失。 从 Store 重新安装会安装分发版的干净副本。 例如：<code>wsl --unregister Ubuntu</code> 将从可用于 WSL 的发行版中删除 Ubuntu。 运行 <code>wsl --list</code> 将会显示它不再列出。</p><h2 id="WSL与Windows互传文件"><a href="#WSL与Windows互传文件" class="headerlink" title="WSL与Windows互传文件"></a>WSL与Windows互传文件</h2><h2 id="WSL报错Error-code-Wsl-Service-0x8007273d"><a href="#WSL报错Error-code-Wsl-Service-0x8007273d" class="headerlink" title="WSL报错Error code: Wsl&#x2F;Service&#x2F;0x8007273d"></a>WSL报错Error code: Wsl&#x2F;Service&#x2F;0x8007273d</h2><p>以管理身份打开cmd&#x2F;powershell，运行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">netsh winsock reset<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wsl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2024/11/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/11/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><p>其实我写过很多博客，确切地说这并不是我的第一篇博客，应该是我自建博客网站的第一篇博客。</p><p>曾经刚来大学时，我也坚持写过几篇博客，不过同大多人一样寥寥数笔介绍完自己所学、自己所见，也就不知道怎么去写了。随后就放弃了这个活动。</p><p>在这个偶然的时间点，对于秋招的迷茫亦或者想找一些事干的我，发现好友山先生的博客网站感觉十分惊奇。于是在山先生的帮助下完成了个人博客的搭建。</p><p>我的好友山先生是一个比较文雅的人，他喜欢吟诗作赋，喜欢将他的才情在笔墨间肆意流淌。他的博客是你看到了会明白这人是那种文人骚客，在他眼中，平凡之物皆有故事，寻常之景皆是诗篇。他喜欢写一些生活的随笔，将情感同涓涓细流从话语中滋润心田。</p><p>我的好友山先生也是比较‘杠’的人，也可能是他的‘杠’，他的博客中大多数都是对于所学专业技术的思考，里面精华不少，推荐可以去观摩观摩。</p><p>也是山先生，我的个人博客网站也在今天完成，虽然是个简单的博客网站，但这些都是我的其他好友C先生，K先生合力帮助完成的。</p><p>他们也是很有趣的好友，K先生是一个中原人，喜欢运动，喜欢按照自己慢慢的节奏生活。C先生是同我一样的荆楚人，喜欢默默地去干很多事情，他是个沉默且真诚的人。</p><p>我们还有个共同好友F先生，他去进步了。F先生的歌唱的很好，虽然他平时不让我们听他唱歌。</p><p>冬天将至，秋招也快结束。我们也越来越迷茫，不知道怎么面对未来。</p><p>我和山先生都各有offer，虽然不是很好的，但至少是有保底的。C先生和K先生就没有任何offer。寝室好像陷入了安静。</p><p>不再似从前欢声笑语，我经常喜欢呼唤他们的名字，希望他们不会默默地沉默。这么做感觉像是寝室又拥有了活力，不过他们好像觉得自己十分有活力。</p><p>秋风扫着枯黄的落叶，秋招也将我们这些双非硕驱逐于门外。没有任何办法，我们也只能如同那些冬眠的动物，静静地等待冬天过去，期待春天能带来好消息。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/04/hello-world/"/>
    <url>/2024/11/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
